Question 1
question1(s,t) takes two inputs s and t. lists and sorts string t. The function check_anagram compares part of string s and sorted list of string t. Time efficiency for sorting is O(n*log(n))

Question 2
Within the for loop there is two if conditions first when the number of alphabets are odd in the string and the other when the number is even. The ‘check(s, c1, c2)’ investigates if the string ‘s’ is palindromic. Efficiency: O(N^2) time and O(1) space.

Question 3
Uses Kruskal algorithm for minimum spanning tree. The basic idea is to sort the edges by its weight and starts include the edge without causing a cycle in the graph. One way to make sure there are no cycle in the graph is by keep track of each vertice in a list of sets. If the new edge will connect two vertices within the same set, we will not include it. Else, we include the set and take union of the sets. This algorithm has many parts. First, generate list of edges will take O(E) time and O(E) space. Second, sort the edges by weight will take O(Elog(E)) time and O(E) space. Third, loop through each edges, find the indices, and merge sets will take worst case O(E*V) time and O(V) space. Lastly, we have to convert the edges back to the required output graph structure that will take O(E) time and O(V) space. Overall my algorithm will take O(E*V) time and O(E) space. However, the overall time complexity can be further reduced to O(E*log(V)) time with "disjoint-set data structure".

Question 4
We will traverse through the tree from top-down and with the BST properties, the least common ancestor between two nodes is just the first node we meet with the value between n1 and n2. We will go left if the current node is greater than both n1 and n2, right if the current node is less than both n1 and n2, else the node is the least common ancestor. Since the worst case we will traverse is the depth of a binary tree, the time complexity will be O(log(n)) (if balanced, else it will be O(n)) where n is the number of elements in the tree. The space complexity is O(1) because we only keep track of the current node at the traversal stage. Special note to deal with the edge case when n1 and/or n2 are not in the tree. We can simply traverse the BST to check if the value exist in the tree. This part will take same time and space complexity as the main algorithm, so it won't increase the overall complexities. 

Question 5
The best way to solve this problem is to just traverse through the linked list twice. The first time we traverse through the linked list to get its length. Then we can determine how many elements to traverse on the second pass to get the mth element from the back. The time will still be O(n) for traverse through ll twice. Since we only store the length, the space complexity will be O(1).
